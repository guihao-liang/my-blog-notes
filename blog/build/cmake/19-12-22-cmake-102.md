---
title: "CMake 101: if I know how if works"
author: Guihao Liang
published: true
---

## big picture

Below is a picture referenced from that post, which depicts the CMake workflow: configuration and generation.
![cmake workflow](https://preshing.com/images/cmake-simple-flowchart.png)

The first step of CMake is configuration, where it executes the `CMakeLists.txt` and figure out **targets** defined in `CMakeLists.txt`.

If the first step goes without an error, it proceeds to the second step, where **targets** will be used by the `generator` to generate build pipelines, which are **input files** for different build system, such as Unix Makefiles, and XCodeproject files, etc.

---

## key concepts

- source file: lowest level, corresponding C/C++ source files; source files are **combined** into targets.
- target: typically executable or library (add_library, add_executable, add_custom_target).
- directory: represent a dir in source tree, and typically has a CMakeLists.txt and one or more targets
- generator: every dir has a local generator that is responsible for generating the Makefiles or project files for that dir. All of the local generators share a common global generator that oversees the build process.

---

## project


## target_compile_definitions

> The INTERFACE, PUBLIC and PRIVATE keywords are required to specify the scope of the following arguments. PRIVATE and PUBLIC items will populate the COMPILE_DEFINITIONS property of <target>. PUBLIC and INTERFACE items will populate the INTERFACE_COMPILE_DEFINITIONS property of <target>. (IMPORTED targets only support INTERFACE items.) The following arguments specify compile definitions. Repeated calls for the same <target> append items in the order called.

Any leading -D on an item will be removed. Empty items are ignored. For example, the following are all equivalent:

```cmake
target_compile_definitions(foo PUBLIC FOO)
target_compile_definitions(foo PUBLIC -DFOO)  # -D removed
target_compile_definitions(foo PUBLIC "" FOO) # "" ignored
target_compile_definitions(foo PUBLIC -D FOO) # -D becomes "", then ignored
```

what is PUBLIC, INTERFACE, PRIVATE ???

## [override the compile flags for single file](https://stackoverflow.com/questions/13638408/override-compile-flags-for-single-files)

In my turicreate project, I made one mistake,

```CM ake
set_source_files_properties(lambda_omp.hpp PROPERTIES COMPILE_FLAGS -fopenmp)
```

I thought when it compiles in the build pipeline, it will include the actual header file in the build command and the flags associated to header file will be picked up.

```bash
make -fopenmp lambda_omp.hpp other_source_include_lambda_omp_hpp.cpp -o ...
```

This quite usual when we use `make` to build a small project what we pass all headers and source files. And headers are part of the entire sources.

But the reality is that `-fopenmp` is never used by the underlying build system. What happens?

Let's first talk about how we can [include headers to targets with CMake](https://stackoverflow.com/questions/13703647/how-to-properly-add-include-directories-with-cmake). We must specify the directory to find header files we need and add both headers and implementation files as dependcencies to the target:

```CMake
set(SOURCES file.cpp file2.cpp ${INCLUDE_DIR}/file1.h ${INCLUDE_DIR}/file2.h)
add_executable(target ${SOURCES})
```

Headers can be dependcencies for a target but `HEADER FILES ARE NOT COMPILED`, and the source files that include the header files are compiled. That's why the `COMPILE_FLAGS` I set for the header file is not used.

Let's also look at the documentation for `set_source_files_properties`:
> These flags will be added to the list of compile flags when this source file builds.
I guess `header file` is never used for build purposes.

If you want to know more modifying compile flags for source files, check this [awesome anwser](https://stackoverflow.com/questions/13638408/override-compile-flags-for-single-files).
